/**
 * IZZICO VULNERABILITY SCANNER & SECURITY ANALYZER
 *
 * Système d'analyse de vulnérabilités automatique
 * Score de sécurité dynamique et recommandations IA
 */

import { createClient } from '@/lib/auth/supabase-client';

export type VulnerabilityType = 'dependency' | 'code' | 'configuration' | 'authentication' | 'data_exposure';
export type VulnerabilitySeverity = 'low' | 'medium' | 'high' | 'critical';
export type VulnerabilityStatus = 'open' | 'in_progress' | 'resolved' | 'accepted_risk' | 'false_positive';

export interface Vulnerability {
  type: VulnerabilityType;
  severity: VulnerabilitySeverity;
  title: string;
  description: string;
  affectedComponent?: string;
  cveId?: string;
  cvssScore?: number;
  remediation?: string;
  fixComplexity?: 'low' | 'medium' | 'high';
  status?: VulnerabilityStatus;
  metadata?: Record<string, any>;
}

export interface SecurityScore {
  overallScore: number; // 0-100
  authenticationScore: number;
  authorizationScore: number;
  dataProtectionScore: number;
  vulnerabilityScore: number;
  monitoringScore: number;
  complianceScore: number;
  criticalIssues: number;
  highIssues: number;
  mediumIssues: number;
  lowIssues: number;
  topRecommendations: string[];
  trend: 'improving' | 'stable' | 'declining';
}

export interface SecurityAuditReport {
  generatedAt: Date;
  score: SecurityScore;
  vulnerabilities: Vulnerability[];
  strengths: string[];
  weaknesses: string[];
  criticalActions: string[];
  recommendations: Array<{
    priority: 'high' | 'medium' | 'low';
    category: string;
    title: string;
    description: string;
    estimatedEffort: string;
    impactOnScore: number;
  }>;
}

class VulnerabilityScanner {
  private static instance: VulnerabilityScanner;
  private supabase = createClient();

  private constructor() {}

  public static getInstance(): VulnerabilityScanner {
    if (!VulnerabilityScanner.instance) {
      VulnerabilityScanner.instance = new VulnerabilityScanner();
    }
    return VulnerabilityScanner.instance;
  }

  /**
   * Enregistrer une vulnérabilité
   */
  public async reportVulnerability(vulnerability: Vulnerability): Promise<void> {
    try {
      const { error } = await this.supabase.from('security_vulnerabilities').insert({
        vulnerability_type: vulnerability.type,
        severity: vulnerability.severity,
        title: vulnerability.title,
        description: vulnerability.description,
        affected_component: vulnerability.affectedComponent,
        cve_id: vulnerability.cveId,
        cvss_score: vulnerability.cvssScore,
        remediation: vulnerability.remediation,
        fix_complexity: vulnerability.fixComplexity,
        status: vulnerability.status || 'open',
        metadata: vulnerability.metadata || {},
      });

      if (error) throw error;

      // Recalculer le score de sécurité
      await this.calculateAndSaveSecurityScore();
    } catch (error) {
      console.error('[VULNERABILITY SCANNER] Failed to report vulnerability:', error);
    }
  }

  /**
   * Scanner les dépendances pour des vulnérabilités connues
   */
  public async scanDependencies(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Liste des dépendances critiques à surveiller
      const criticalDeps = [
        'next',
        'react',
        '@supabase/supabase-js',
        '@sentry/nextjs',
      ];

      // Vérifications basiques de configuration
      // En production, intégrer avec des APIs comme Snyk, GitHub Security, etc.

      // Exemple: Vérifier si Sentry est configuré
      if (!process.env.NEXT_PUBLIC_SENTRY_DSN) {
        vulnerabilities.push({
          type: 'configuration',
          severity: 'medium',
          title: 'Sentry not configured',
          description: 'Error tracking is not properly configured, making it difficult to monitor production issues',
          affectedComponent: 'Monitoring',
          remediation: 'Configure NEXT_PUBLIC_SENTRY_DSN in environment variables',
          fixComplexity: 'low',
        });
      }

      // Vérifier si rate limiting est activé
      if (!process.env.UPSTASH_REDIS_REST_URL) {
        vulnerabilities.push({
          type: 'configuration',
          severity: 'high',
          title: 'Rate limiting not configured',
          description: 'API endpoints are not protected by rate limiting, vulnerable to abuse and DDoS',
          affectedComponent: 'API Security',
          remediation: 'Configure Upstash Redis for rate limiting',
          fixComplexity: 'medium',
        });
      }

      // Vérifier HTTPS
      if (process.env.NODE_ENV === 'production' && !process.env.NEXT_PUBLIC_SITE_URL?.startsWith('https://')) {
        vulnerabilities.push({
          type: 'configuration',
          severity: 'critical',
          title: 'HTTPS not enforced',
          description: 'Site is not using HTTPS, exposing user data to man-in-the-middle attacks',
          affectedComponent: 'Network Security',
          remediation: 'Enforce HTTPS on all pages and APIs',
          fixComplexity: 'low',
        });
      }

      // Vérifier les secrets en dur (scan basique)
      // En production, utiliser des outils comme TruffleHog, GitGuardian

      return vulnerabilities;
    } catch (error) {
      console.error('[VULNERABILITY SCANNER] Failed to scan dependencies:', error);
      return [];
    }
  }

  /**
   * Scanner le code pour des patterns de sécurité
   */
  public async scanCodePatterns(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Vérifications de configuration de sécurité

    // 1. Vérifier les headers de sécurité
    const securityHeaders = {
      'X-Frame-Options': 'DENY',
      'X-Content-Type-Options': 'nosniff',
      'Referrer-Policy': 'strict-origin-when-cross-origin',
      'Permissions-Policy': 'geolocation=(), microphone=(), camera=()',
    };

    // En production, vérifier si ces headers sont présents
    if (process.env.NODE_ENV === 'production') {
      vulnerabilities.push({
        type: 'configuration',
        severity: 'medium',
        title: 'Security headers not fully configured',
        description: 'Missing recommended security headers (X-Frame-Options, CSP, etc.)',
        affectedComponent: 'HTTP Headers',
        remediation: 'Add security headers in next.config.js',
        fixComplexity: 'low',
      });
    }

    // 2. Vérifier la configuration CORS
    vulnerabilities.push({
      type: 'configuration',
      severity: 'low',
      title: 'Review CORS configuration',
      description: 'Ensure CORS is properly configured to prevent unauthorized cross-origin requests',
      affectedComponent: 'API Security',
      remediation: 'Review and restrict CORS origins in production',
      fixComplexity: 'low',
    });

    return vulnerabilities;
  }

  /**
   * Analyser les configurations d'authentification et d'autorisation
   */
  public async analyzeAuthSecurity(): Promise<{
    score: number;
    issues: string[];
    recommendations: string[];
  }> {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    try {
      // Vérifier si MFA est disponible
      // Cette vérification devrait être faite en analysant la config Supabase
      recommendations.push('Consider implementing Multi-Factor Authentication (MFA)');

      // Vérifier la politique de mots de passe
      recommendations.push('Enforce strong password policy (min 12 chars, complexity requirements)');

      // Vérifier les sessions
      recommendations.push('Implement session timeout after 30 minutes of inactivity');

      // Vérifier les tentatives de connexion
      const { count: recentAuthFailures } = await this.supabase
        .from('security_events')
        .select('*', { count: 'exact', head: true })
        .eq('event_type', 'auth_failure')
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

      if ((recentAuthFailures || 0) > 100) {
        issues.push('High number of authentication failures detected');
        score -= 10;
      }

      // Vérifier les tokens JWT
      if (!process.env.SUPABASE_JWT_SECRET) {
        issues.push('JWT secret not properly configured');
        score -= 15;
      }

      return { score, issues, recommendations };
    } catch (error) {
      console.error('[VULNERABILITY SCANNER] Failed to analyze auth security:', error);
      return { score: 50, issues: ['Failed to analyze'], recommendations: [] };
    }
  }

  /**
   * Analyser la protection des données
   */
  public async analyzeDataProtection(): Promise<{
    score: number;
    issues: string[];
    recommendations: string[];
  }> {
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    // Vérifier le chiffrement
    if (process.env.NODE_ENV === 'production') {
      recommendations.push('Ensure all sensitive data is encrypted at rest');
      recommendations.push('Use field-level encryption for PII (email, phone, etc.)');
    }

    // Vérifier les backups
    recommendations.push('Implement automated database backups with encryption');
    recommendations.push('Test backup restoration procedure quarterly');

    // Vérifier la conformité RGPD
    recommendations.push('Implement data retention policies (GDPR compliance)');
    recommendations.push('Add user data export functionality');
    recommendations.push('Implement right to be forgotten (data deletion)');

    // Vérifier les logs
    try {
      const { count: dataExposureEvents } = await this.supabase
        .from('security_events')
        .select('*', { count: 'exact', head: true })
        .eq('event_type', 'data_breach_attempt')
        .gte('created_at', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString());

      if ((dataExposureEvents || 0) > 0) {
        issues.push('Data breach attempts detected');
        score -= 20;
      }
    } catch (error) {
      console.error('[VULNERABILITY SCANNER] Failed to check data exposure events:', error);
    }

    return { score, issues, recommendations };
  }

  /**
   * Calculer le score de sécurité global
   */
  public async calculateSecurityScore(): Promise<SecurityScore> {
    try {
      // Analyser différents aspects
      const authAnalysis = await this.analyzeAuthSecurity();
      const dataProtectionAnalysis = await this.analyzeDataProtection();

      // Compter les vulnérabilités non résolues
      const { data: vulnerabilities } = await this.supabase
        .from('security_vulnerabilities')
        .select('severity, status')
        .in('status', ['open', 'in_progress']);

      const criticalIssues = vulnerabilities?.filter(v => v.severity === 'critical').length || 0;
      const highIssues = vulnerabilities?.filter(v => v.severity === 'high').length || 0;
      const mediumIssues = vulnerabilities?.filter(v => v.severity === 'medium').length || 0;
      const lowIssues = vulnerabilities?.filter(v => v.severity === 'low').length || 0;

      // Compter les erreurs récentes
      const { count: recentCriticalErrors } = await this.supabase
        .from('security_errors')
        .select('*', { count: 'exact', head: true })
        .eq('severity', 'critical')
        .eq('resolved', false)
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

      const { count: recentHighErrors } = await this.supabase
        .from('security_errors')
        .select('*', { count: 'exact', head: true })
        .eq('severity', 'high')
        .eq('resolved', false)
        .gte('created_at', new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString());

      // Score de vulnérabilités (commence à 100, déductions)
      let vulnerabilityScore = 100;
      vulnerabilityScore -= criticalIssues * 20;
      vulnerabilityScore -= highIssues * 10;
      vulnerabilityScore -= mediumIssues * 5;
      vulnerabilityScore -= lowIssues * 2;
      vulnerabilityScore = Math.max(0, vulnerabilityScore);

      // Score de monitoring (basé sur la présence d'erreurs non résolues)
      let monitoringScore = 100;
      monitoringScore -= (recentCriticalErrors || 0) * 15;
      monitoringScore -= (recentHighErrors || 0) * 5;
      monitoringScore = Math.max(0, monitoringScore);

      // Score de conformité (basé sur les recommandations de data protection)
      const complianceScore = dataProtectionAnalysis.issues.length === 0 ? 90 : 70;

      // Calculer le score global (moyenne pondérée)
      const overallScore = Math.round(
        authAnalysis.score * 0.25 +
        dataProtectionAnalysis.score * 0.25 +
        vulnerabilityScore * 0.25 +
        monitoringScore * 0.15 +
        complianceScore * 0.10
      );

      // Collecter les recommandations top
      const topRecommendations = [
        ...authAnalysis.recommendations.slice(0, 2),
        ...dataProtectionAnalysis.recommendations.slice(0, 2),
      ];

      // Déterminer la tendance
      const { data: previousScore } = await this.supabase
        .from('security_score_history')
        .select('overall_score')
        .order('calculated_at', { ascending: false })
        .limit(1)
        .single();

      let trend: 'improving' | 'stable' | 'declining' = 'stable';
      if (previousScore) {
        const diff = overallScore - previousScore.overall_score;
        if (diff > 5) trend = 'improving';
        else if (diff < -5) trend = 'declining';
      }

      return {
        overallScore,
        authenticationScore: authAnalysis.score,
        authorizationScore: 85, // Placeholder
        dataProtectionScore: dataProtectionAnalysis.score,
        vulnerabilityScore,
        monitoringScore,
        complianceScore,
        criticalIssues: criticalIssues + (recentCriticalErrors || 0),
        highIssues: highIssues + (recentHighErrors || 0),
        mediumIssues,
        lowIssues,
        topRecommendations,
        trend,
      };
    } catch (error) {
      console.error('[VULNERABILITY SCANNER] Failed to calculate security score:', error);
      return {
        overallScore: 0,
        authenticationScore: 0,
        authorizationScore: 0,
        dataProtectionScore: 0,
        vulnerabilityScore: 0,
        monitoringScore: 0,
        complianceScore: 0,
        criticalIssues: 0,
        highIssues: 0,
        mediumIssues: 0,
        lowIssues: 0,
        topRecommendations: [],
        trend: 'stable',
      };
    }
  }

  /**
   * Calculer et sauvegarder le score de sécurité
   */
  public async calculateAndSaveSecurityScore(): Promise<SecurityScore> {
    try {
      const score = await this.calculateSecurityScore();

      const { error } = await this.supabase.from('security_score_history').insert({
        overall_score: score.overallScore,
        authentication_score: score.authenticationScore,
        authorization_score: score.authorizationScore,
        data_protection_score: score.dataProtectionScore,
        vulnerability_score: score.vulnerabilityScore,
        monitoring_score: score.monitoringScore,
        compliance_score: score.complianceScore,
        critical_issues: score.criticalIssues,
        high_issues: score.highIssues,
        medium_issues: score.mediumIssues,
        low_issues: score.lowIssues,
        top_recommendations: score.topRecommendations,
      });

      if (error) throw error;

      return score;
    } catch (error) {
      console.error('[VULNERABILITY SCANNER] Failed to save security score:', error);
      return await this.calculateSecurityScore();
    }
  }

  /**
   * Générer un rapport d'audit de sécurité complet
   */
  public async generateSecurityAuditReport(): Promise<SecurityAuditReport> {
    try {
      const score = await this.calculateSecurityScore();
      const depVulns = await this.scanDependencies();
      const codeVulns = await this.scanCodePatterns();
      const authAnalysis = await this.analyzeAuthSecurity();
      const dataAnalysis = await this.analyzeDataProtection();

      // Récupérer les vulnérabilités de la base de données
      const { data: dbVulns } = await this.supabase
        .from('security_vulnerabilities')
        .select('*')
        .in('status', ['open', 'in_progress'])
        .order('severity', { ascending: false });

      const allVulnerabilities = [
        ...depVulns,
        ...codeVulns,
        ...(dbVulns?.map(v => ({
          type: v.vulnerability_type as VulnerabilityType,
          severity: v.severity as VulnerabilitySeverity,
          title: v.title,
          description: v.description,
          affectedComponent: v.affected_component,
          cveId: v.cve_id,
          cvssScore: v.cvss_score,
          remediation: v.remediation,
          fixComplexity: v.fix_complexity as 'low' | 'medium' | 'high',
          status: v.status as VulnerabilityStatus,
        })) || []),
      ];

      // Identifier les forces
      const strengths: string[] = [];
      if (score.authenticationScore >= 90) strengths.push('Strong authentication mechanisms');
      if (score.dataProtectionScore >= 90) strengths.push('Excellent data protection');
      if (score.monitoringScore >= 90) strengths.push('Comprehensive monitoring in place');
      if (score.vulnerabilityScore >= 90) strengths.push('Minimal known vulnerabilities');

      // Identifier les faiblesses
      const weaknesses: string[] = [];
      if (score.authenticationScore < 70) weaknesses.push('Authentication security needs improvement');
      if (score.dataProtectionScore < 70) weaknesses.push('Data protection measures insufficient');
      if (score.monitoringScore < 70) weaknesses.push('Monitoring coverage incomplete');
      if (score.vulnerabilityScore < 70) weaknesses.push('Multiple unresolved vulnerabilities');

      // Actions critiques
      const criticalActions: string[] = [];
      if (score.criticalIssues > 0) {
        criticalActions.push(`Resolve ${score.criticalIssues} critical security issues immediately`);
      }
      if (score.highIssues > 5) {
        criticalActions.push(`Address ${score.highIssues} high-priority security issues`);
      }
      authAnalysis.issues.forEach(issue => criticalActions.push(issue));

      // Recommandations détaillées
      const recommendations = [
        {
          priority: 'high' as const,
          category: 'Authentication',
          title: 'Implement Multi-Factor Authentication',
          description: 'Add MFA for admin accounts and optionally for all users',
          estimatedEffort: '2-3 days',
          impactOnScore: 8,
        },
        {
          priority: 'high' as const,
          category: 'Monitoring',
          title: 'Configure comprehensive error tracking',
          description: 'Ensure Sentry is fully configured with source maps and user context',
          estimatedEffort: '1 day',
          impactOnScore: 5,
        },
        {
          priority: 'medium' as const,
          category: 'Data Protection',
          title: 'Implement field-level encryption',
          description: 'Encrypt sensitive PII fields at the database level',
          estimatedEffort: '3-5 days',
          impactOnScore: 10,
        },
        {
          priority: 'medium' as const,
          category: 'Compliance',
          title: 'Add GDPR compliance features',
          description: 'Implement data export, deletion, and retention policies',
          estimatedEffort: '5-7 days',
          impactOnScore: 12,
        },
        {
          priority: 'low' as const,
          category: 'Infrastructure',
          title: 'Set up automated security scanning',
          description: 'Integrate Snyk or Dependabot for automated dependency scanning',
          estimatedEffort: '1-2 days',
          impactOnScore: 5,
        },
      ];

      return {
        generatedAt: new Date(),
        score,
        vulnerabilities: allVulnerabilities,
        strengths,
        weaknesses,
        criticalActions,
        recommendations,
      };
    } catch (error) {
      console.error('[VULNERABILITY SCANNER] Failed to generate audit report:', error);
      throw error;
    }
  }
}

// Export singleton
export const vulnerabilityScanner = VulnerabilityScanner.getInstance();
